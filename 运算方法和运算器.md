|Author|Date|
|---|---|
|MZJ|3/9,2022|
---

>数据类型:  
>按照数制：十进制（微机中运算困难），二进制（占用存储空间小，硬件上易于实现，易于运算），十六进制（方便观察和使用）  
>按照数据格式：真值（带有正负号的数据）和机器数（符号化的数值表示，分为原码，反码，补码等编码）  
>按照数据表示范围：定点数（小数点位置固定，表示范围小）和浮点数（小数点的位置不固定，表示范围大）  
 >按能否表示负数：有符号数和无符号数

正数的补码和反码为其本身，负数补码除符号位取反加一，负数的反码除符号位取反。  
数的原码表示在于数字化符号，1表示负，0表示正。  
[+0]原=0000，[-0]原=1000
[+0]补=0000，[-0]补=0000

模的概念：当运算结果超过实际的最大表示范围，就会发生溢出，此时所产生的溢出量就是模。  
定点小数的溢出量为2；一个字长为n+1的定点整数的溢出量为2^n+1  
在计算机中机器能够表示的数据位数是固定的，其运算为有模运算，如果运算结果超过其表示范围，则丢弃进位部分。
补码由模得出，负数需要加上模，求得其补码。
[x]补 求[-x]补，连同符号位取反加1，反过来同样适用。  

移码：常用来表示浮点数的阶码，[x]移=2^n+X，n为x数值位的个数，与[X]补符号位相反。  
在移码中最高位为0表示负数，为1表示正数，移码全为0是最小，全为1时最大，因此移码的大小反映了真值的大小，有利于比较两个浮点数阶码的大小。  
真值0在移码中的表示是唯一的，[+0]移=[-0]移=1000，因为其补码是唯一的。  
移码将真值映射到一个正数域，可将移码视做一个无符号数，直接按照无符号数的规则比较大小。  

浮点数:N=R^e * M  
M为尾数，是一个纯小数，其位数决定数值精度；R为基数一般取2，表示当前的数制；e为阶码，是一个整数，用于指出小数点在数中的位置，其位数决定着数据的取值范围。  
表示形式：阶符-阶码-数符-尾数或者数符-阶符-阶码-尾数  
浮点数的规格化：尾数原码表示，最高数值位为1，正数0.1...，负数1.1...  ；尾数补码表示：正数0.1...，负数1.0...；  

一般的机器中浮点数采用IEEE754标准存放float和double类型变量。   
>IEEE754标准32位浮点数的标准格式:1+8+23,分别表示数符S+阶码E(包括阶符)+尾数M  
>M为原码纯小数表示，小数点在尾数域的最前面，由于原码的规格化浮点数要求，最高位数值始终为1，故将其隐藏，尾数实际值为1.M。  
>阶码8位采用有偏移值的移127码表示 E=127+e  
>N=(-1)^s * 1.M * 2^(E-127)  

>IEEE754标准64位浮点数的标准格式:1+11+52,分别表示数符s+阶码E(包括阶符)+尾数M  
>N = (-1)^S * 1.M * 2^(E-1023)   

>IEEE754标准32位浮点数阶码E：0000 0000 ~ 1111 1111  
>正0负0，E = 0000 0000 ,M=0000...0000，正负之分由数符确定  
>正无穷，负无穷 E = 1111 1111，M = 0000...0000，正负之分由数符确定  
>阶码其余的值0000 0001 ~ 1111 1110,才是真正的阶码取值，因为0000 0000 和1111 1111 都有不同寻常的意义，所以E ：1 ~ 254，e:-126 ~ +127  

float和double的精度都由尾数的位数来决定；
float类型 2^23=8388608,最多能有7位有效数字，但绝对能保证6位有效数字，则精度为6~7位  
double类型 2^52=4503599627370496,最多能有16位有效数字，但绝对能保证15位有效数字，则精度为15~16位.  

十进制数串表示方法： 
字符串形式：每个十进制数位占用一个字节，除保存各数位还需要指明该数存放的起始地址和总位数。 主要用于非数值计算的应用领域。  
压缩的十进制数串形式:采用BCD码表示，一个字节可存放两个十进制数位；节省内存空间，便于完成十进制数的算术运算，用特殊的二进制编码表示数据正负。

非数值数据：
字符的表示方法：非数值领域的问题需要引入文字字母以及某些专用符号以便表示文字语言，逻辑语言等信息。如ASCII码 汉字的编码:输入码和机内码  
ASCII码：7位编码，规定最高位为0，余下7位作为128个字符的编码；最高位作用：奇偶校验，扩展编码。  
字符串：连续的一串字符，每个字符占一个字节。  
汉字的输入编码： 直接使用西文标准键盘把汉字输入到计算机，主要有数字编码，拼音码，字形编码三类。  
汉字机内码：用于汉字信息的存储，交换，检索等操作的机内代码，如GB2312，Unicode等编码。  
汉字字模码：用点阵表示的汉字字形代码，用于汉字的输出。  
中文编码过程:  
汉字键盘输入码->通过汉字处理程序和代码转换程序借助码表转换为机内码->汉字机内码（2字节）->字型检索程序借助汉字库(汉字字形点阵32字节16 * 16)->显示驱动程序->显示存储器->显示器    

>校验码：  
>原因:为减少和避免数据在计算机系统在运行或传送时出现错误，在编码上提供了检错和纠错的支持。  
>定义:能够发现某些错误或具有自动纠错能力的数据编码。  
>数据校验的基本原理是扩大码距。码距是任意两个合法码之间不同的二进制位的最少个数。至少有1位不同时其码距为1. 

|a0|a1|a2|
|---|---|---|
|0|0|0|
|0|0|1|
|0|1|0|
|0|1|1|
|1|0|0|
|1|0|1|
|1|1|0|
|1|1|1|

表中用3bit来表示8个不同的信息。在这个系统中，任意码字的有1~3位bit不同，但其最小为1，故该系统码距为1.  
如果任何码字中一位或多位出错，结果这个码字就不能与其它有效信息区分开。例如，如果传送信息001，而被误收为011，因011仍是表中的合法码字，接收机仍将认为011是正确的信息。  

|a0|a1|a2|a3|
|---|---|---|---|
|0|0|0|0|
|1|0|0|1|
|1|0|1|0|
|0|0|1|1|
|1|1|0|0|
|0|1|0|1|
|0|1|1|0|
|1|1|1|1|

表中任意两种码字中至少有2bit不同，故其码距为2。  
如果任何信息的一个数位出错，就成为一个不用的码字，接收机能检查出来。
例如信息是1001，误收为1011，接收机知道发生了一个差错，因为1011不是一个码字（表中没有）。但差错无法被纠正，假定只有一个数位是错的，正确码字可以是1001，1111，0011或1010。接收者不能确定原来到底是这4个码字中的那一个。也可看到， 在这个系统中，偶数个（2或4）差错也无法发现。  
为了使一个系统能检查和纠正一个差错，码间最小距离必须至少是3。最小距离为3时，或能纠正一个错，或能检二个错，但不能同时纠一个错和检二个错。  
编码信息纠错和检错能力的进一步提高需要进一步增加码字间的最小距离。码距越大，纠错和检错能力越强，数据冗余越大，编码效率越低。  

|校验码类型|介绍|
|---|---|
|奇偶校验码|根据数据中1的个数，设置1位校验位的值，只能检错无法纠错且只能检验出奇数个错误。|
|海明校验码|在奇偶校验位的基础上增加校验位的个数而得，可以纠错和检错|
|循环冗余校验码(CRC)|通过模2的除法运算建立数据信息和校验位之间的约定关系，具有很强的纠错和检错能力|

奇偶校验码  
海明码  
循环冗余校验码  

补码运算：


